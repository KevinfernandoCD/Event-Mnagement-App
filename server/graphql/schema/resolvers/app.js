const EventModel = require('../../../models/eventModel'); 
const UserModel = require('../../../models/userModel');
const BookingModel = require('../../../models/bookingModel');
const bcrypt = require('bcryptjs');
const {DateToString} = require('../../../helpers/DateToString');
const jwt = require("jsonwebtoken");


const events =  (eventids) => {

    return EventModel.find({_id: {$in:eventids}})

    .then(events => {

        return events.map(event => {

            return {...event._doc,id:event._id,creator:user.bind(this,event._doc.creator),date:new Date(event._doc.date).toISOString()}
            
        })

    }).catch(err => {

        throw err

    })

}

const user = (userid) => {

    return UserModel.findById(userid).then(user => {

        return {...user._doc,id:user._id,createdEvents:events.bind(this,user._doc.createdEvents)}

    }).catch(err => {

        throw err
    })
}

const singleEvent = async(eventId) => {

    const fetchEvent = await EventModel.findById(eventId)

    return {
        ...fetchEvent._doc,id:fetchEvent._doc._id,creator:user.bind(this,fetchEvent._doc.creator),date:DateToString(fetchEvent._doc.date)
    }

}

const transformEvent = event => {

    return {...event._doc,id:event._doc._id.toString(),creator:user.bind(this,event._doc.creator),date:DateToString(event._doc.date)}

}

const transformUser = user => {

    return {...user._doc,id:user._doc._id,createdEvents:events.bind(this,user._doc.createdEvents)}
}

const transformBooking = booking => {

    return {

            ...booking._doc,_id:booking._doc._id,
            bookeduser:user.bind(this,booking._doc.bookeduser),
            event:singleEvent.bind(this,booking._doc.event),
            createdAt:DateToString(booking._doc.createdAt),
            updatedAt:DateToString(booking._doc.updatedAt)
        
       }
}

module.exports = {

        //RESOLVERS

        /*THIS IS WHERE WE CALL ALL OF OUR RESOLVERS
        OF OUR WRITTEN QUERIES IN OUT ROOT QUERY OBJECT 
        THE QUERY NAMES SHOULD BE EXACTLY SAME*/
        getEvents : () => {

           return EventModel.find()
            
            .then(events => {

                return events.map(event => {

                    //ONLY THE ID WE NEED TO CONVERT IT TO A STRING BECAUSE IT HAS A SPECIFIC OBJECT TYPE

                    return transformEvent(event)
                })
            }).catch(err => console.log(err))

        },

        createEvent : (args,req) => {

              if(!req.isAuth){

                throw new Error('User Unautharized')

            }

            let createdEvent 

            const event = new EventModel({
                
                title:args.eventInput.title,
                description:args.eventInput.description,
                type:args.eventInput.type,
                price:args.eventInput.price,
                date:new Date(args.eventInput.date),
                creator:req.userId,

            })


          return event.save().then(event => {

            createdEvent = transformEvent(event)

               return UserModel.findById(req.userId)

            })

            .then(user => {

                user.createdEvents.push(createdEvent.id)
                return user.save()
                 
            })

            .then(result => {

                 return createdEvent
            })
            
            .catch(err => console.log(err))

        },

        getUsers : () => {

            return UserModel.find()
            
            .then(users => {

                return users.map(user => {

                    return transformUser(user)
                })

            }).catch(err => {

                throw err

            })

        },

        createUser : (args) => {

            return UserModel.findOne({email:args.eventInput.email})
            
            .then(user => {

            if(user){

                throw new Error('User Already Exists')

            }else{

                return bcrypt.hash(args.eventInput.password, 12)

                .then(hashedPassword => {

            const newUser = new UserModel({
                
                email:args.eventInput.email,
                password:hashedPassword,
                createdEvents:[]

            })
            
           return newUser.save()
           
           .then(user =>{

            return transformUser(user)

            }).catch(err => console.log(err))

        }).catch(err => { 

            throw err
        })

        }

      })

        },

        getBookings : async(args,req) => {


         if(!req.isAuth){

                throw new Error('User Unautharized')

            }
       

    const bookings = await BookingModel.find()

    

    const allBookings = bookings.map(booking => {

        return {

            ...booking._doc,_id:booking._doc._id,
            bookeduser:user.bind(this,booking._doc.bookeduser),
            event:singleEvent.bind(this,booking._doc.event),
            createdAt:DateToString(booking._doc.createdAt),
            updatedAt:DateToString(booking._doc.updatedAt)
        
       }
    })

    return allBookings

        },

        bookEvent : async(args,req) => {

            if(!req.isAuth){

                throw new Error('User Unautharized')

            }

        const fetchedUser = await UserModel.findOne({_id:req.userId})
        const fetchedEvent = await EventModel.findOne({_id:args.eventId})

        const booking =  new BookingModel({

            bookeduser:fetchedUser,
            event:fetchedEvent

        });

       const result =  await booking.save()

       return transformBooking(result)

        },

        cancelBooking : async(args,req) => {

        try{

            const booking = await BookingModel.findById(args.bookingId).populate("event")

            const event = {...booking.event,id:booking.event._id,creator:user.bind(this,booking.event.creator)}

            await BookingModel.deleteOne({_id:args.bookingId})

            return event

        }catch(err){

            throw err

        }

        },
        
        login : async(args) => {


        const user  = await UserModel.findOne({email:args.email})

            if(!user){

                throw new Error('No User Found')
            }

         const isEqual  =  await bcrypt.compare(args.password, user.password);

           if(!isEqual){

               throw new Error('Invalid password')
         }

         const token = jwt.sign({userId:user._id,email:user.email},'book_me_jwt_sign_key',{expiresIn :'3h'})

         return {

            userId:user._id,email:user.email,token:token,tokenExpiration:3

         }

    }
}






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































